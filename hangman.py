# An implementation of Hangman
# I created it because I never programmed in Python before.

# I prefer this version over hangman2.py, 
# because the 'UI' and logic are separated.
# By 'UI' I mean any code that does print().
# Nowhere should we use print() except in this file and
# also this file should not contain any 'business logic',
# even it is just hangman.
# The problem with this version is that it is hard to remain DRY,
# because some of the states that the 'backend' returns 
# (i.e. what comes from the utils.py stuff)
# are difficult to incorporate in the logic flow.
# Specifically, there is some code duplication after DuplicateNoMatch and NoMatch.
# It is just 3 lines, but it is still really ugly 
# and I am struggling to find a good way to get rid of it.

import sys
import settings as gs # gs alias for 'global settings'
from utils import *
#from ascii_art import *
import ascii_art
from cli_args import *

def main(argv):
    # get command line arguments
    args = cli(argv)
    easyMode = args.easy
    # preliminary setup
    # wordList = gs.WORDLIST # generated by PowerShell from larger OpenTaal source file
    wordList = args.wordlist if args.wordlist != [None] else gs.WORDLIST
    answer = gs.DEBUG_ANSWER if args.debug else choose_line(wordList, args.length)
    wordLength = len(answer)
    hint = gs.HINTINDICATOR * wordLength
    guessesLeft = args.numguesses if args.numguesses != [None] else gs.NUMGUESSES # guessesLeft will decrement
    # main program loop
    while guessesLeft > 0:

        print('H A N G M A N')
        try:
            print(HANGMAN_PICS[gs.NUMGUESSES - guessesLeft])
        except Exception:
            pass
        print(hint)
        print("")
        guess = input(f"Please enter a single character to guess:\nYou have {guessesLeft} tries left.\n" )
        state = evaluate_answer_state(answer, hint, guess)
        match state:
            case AnswerState.NoInput:
                print("No input provided. Please try again")
                continue
            case AnswerState.InvalidCharacter:
                print("Invalid character input. Please try again.")
                continue
            case AnswerState.InvalidLength:
                print("Invalid input length. Please try again.")
                continue
            case AnswerState.DuplicateMatch:
                print(f"You already found the character '{guess}'. Please try again.")
                continue
            case AnswerState.DuplicateNoMatch:
                if easyMode:
                    print(f"You already tried '{guess}' silly!")
                    continue
                else:
                    print(f"Too bad. The answer does not contain '{guess}'.")
                    # code challenge
                    # duplicate of NoMatch output. Ideally want to refactor (DRY principle) but not sure how yet.
                    # the simplest way would probably to move the logic from EvaluateAnswerState to main loop,
                    # but that would make the logic more messy, being intertwined with the 'UI' part.
                    guessesLeft -= 1
                    if guessesLeft > 0:
                        continue
            case AnswerState.NoMatch:
                print(f"Too bad. The answer does not contain '{guess}'.")
                guessesLeft -= 1
                if guessesLeft > 0:
                    continue
            case AnswerState.Match:
                hint = replace_character_in_same_sized_string(answer, hint, guess)
                if hint == answer or guess == answer:
                    print(f"Congratulations! You found the answer '{answer.upper()}' with {guessesLeft} tries left.")
                    input("Press Enter to close the program.")
                    break
                print(f"Nice one! The answer does indeed contain '{guess}'.")
                continue
        print(f"Oh dear. You did not guess the word. The word was '{answer.upper()}'. Better luck next time.")

# I did not understand this at first but this is very important.
# When you modulize things it provides an entry point for other scripts.
if __name__ == '__main__':
    sys.exit(main(sys.argv)) # what does sys.exit mean?