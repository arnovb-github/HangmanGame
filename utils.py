import random
from enum import Flag, auto
import os

charactersGuessed = []

# this implementation is problematic
# the default wordlist used here is one generated by PowerShell 5.1 (i.e., not Core)
def choose_line(file_name):
	# do we have an abnsolute path or a relative one?\
	if not os.path.isabs(file_name):
		file_name = GetFullPath(file_name)
	# also see https://stackoverflow.com/questions/68487529/how-to-ensure-python-prints-utf-8-and-not-utf-16-le-when-piped-in-powershell
	with open(file_name, 'r', encoding='utf16') as file: # you need UTF16 when file was written by Powershell (not Core)
		lines = file.readlines() 
		random_line = random.choice(lines).rstrip().lower() # if you don't strip you may be left with a dangling \r on Windows
	return random_line 

def GetFullPath(relativePath):
	dirname = os.path.dirname(__file__)
	return os.path.join(dirname, relativePath)

# a simple Enum would suffice,
# but Flag is more flexible
class AnswerState(Flag):
	NoMatch = auto()
	Match = auto()
	DuplicateMatch = auto()
	InvalidCharacter = auto()
	InvalidLength = auto()
	NoInput = auto()
	DuplicateNoMatch = auto()

def EvaluateAnswerState(answer, hint, guess):
	# no input
	if not guess:
		return AnswerState.NoInput
	# too long
	if len(guess) > 1:
		# we're going to allow for a cheat:
		# you can type in the entire answer,
		# allowing for immediate exit.
		if guess == answer:
			return AnswerState.Match
		return AnswerState.InvalidLength
	# invalid input
	if not guess.isalpha():
		return AnswerState.InvalidCharacter	
	# DuplicateMatch
	if guess in hint:
		return AnswerState.DuplicateMatch
	# Match
	if guess in answer:
		return AnswerState.Match
	# DuplicateGuess
	if charactersGuessed.count(guess) > 0:
		return AnswerState.DuplicateNoMatch
	# store already guessed characters
	if not charactersGuessed.count(guess) > 0:
		charactersGuessed.append(guess)
	# implement and include flag here for both Duplicate and NoMatch? 
	# NoMatch (default)
	return AnswerState.NoMatch

def ReplaceCharacterInSameSizedString(answer, hint, char):
	# assumes that hint is already same size as answer
	assert(len(answer) == len(hint)), "Hint and answer are not same length."
	newHint = [None] * len(answer) # declare empty list of size answer
	# loop over hint to get what we already got, including hint indicator
	for i, j in enumerate(hint):
		newHint[i] = j
	# get matching char from answer and put it in hint
	for x, y in enumerate(answer):
		if y == char:
			newHint[x] = y
	return ''.join(newHint) # return list as string